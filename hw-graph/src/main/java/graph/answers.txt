CSE 331 Homework.  Answers to written questions.
Edit this file to supply your answers.

Name:  Chandra Burnham

Part 1. (Written exercises)

(a)
IntQueue1
---------------
- Abstraction function:
Entries is a LinkedList of Integer representing the IntQueue. Index 0 represents
the front of the IntQueue while the last index is the back of the IntQueue. Elements
are removed from the front and appended to the back.

    AF(r) = Queue<Integer> q such that
            q = [] if entries is empty
            q = [n1, n2, ..., n_k] where k is the number of elements in entries

- Representation invariant:
    entries != null && !(entries.contains(null))

IntQueue 2
---------------
- Abstraction function:
Entries is an array of Integer containing non-null elements of the queue from
entries[n(front), ..., n(front + (size - 1))]. Front is the index of entries that
represents the front of data in the queue, (size - 1) is the index of entries that
represents the back of the queue, and size represents the number of elements in the
queue. Elements are removed from the front and appended to the back. Entries works
as a circular ring buffer in which appending elements after the queue is full will
overwrite subsequent data at the front of the queue.

    AF(r) = Queue<Integer> q such that
            entries = [n1, n2, ..., n_k] where k is the number of elements in entries
            q = [] if size == 0 (if entries is empty)
            q = [n(front), ..., n(front + size - 1)] if (front + size - 1) <= entries.length
            Circular case:
            q = [n(front), ..., n_k, n1, ..., n(k - front)] if (front + size - 1) > entries.length

- Representation invariant:
    (entries != null) && !(entries.contains(null)) &&
    (0 <= size <= entries.length) && (0 <= front < entries.length)

(b)
(a = d = g), (b = h), (c = f)

a = [1, 2]
b = [2, 3, 4]
c = [1, 2, 3]
d = [1, 2]
e = [1, 2, 3, 4]
f = [1, 2, 3]
g = [1, 2]
h = [2, 3, 4]

(c)
1. No rep exposure: solveEquations takes in and returns data of type int
which is a primitive data type.

2. May be rep exposure: decode returns a mutable array of String[].

3. It depends: if Date is immutable and the returned Date is a copy of the
original Date, then this method may not have rep exposure.

4. No rep exposure: toString returns a String which is immutable.

5. It depends: if the returned Iterator references this collection and has
a remove method, the client can access an Integer in the collection while
iterating through it and therefore there is rep exposure.

6. It depends: if Deck creates a copy of cards that is taken as an argument,
then the client cannot access the original cards and modify it, and therefore
there is no rep exposure.

Part 2.  (Graph interface/operations)

DirectLGraph (top-level class): In the graph class, it contains the mapping of
the nodes and their children. The graph has methods to retrieve the nodes, check if
nodes/edges exist in the current graph, add/remove edges, add nodes, list the
children of a specified node, and provide a string representation of the
current graph. I included these methods because these are basic operations that
the client should be able to expect when modifying their graph, similar to
Sets or Lists. However, I omitted a method to remove an individual node for now
since removing a node may cause complications when accounting for edges that
dependent upon said node.

GraphEdge (helper class): I decided to separate the graph from the edge since edges
function as sub-components of a graph, and it would make implementation easier
to break this down into parts like we did for RatTerms and RatPoly. In the Edge
class, it stores information, about a single edge from one node to another. It
is immutable and stores the source node, the destination node, and the label for
this edge, as well as a string representation of the edge. It also overrides
equals and hashCode to compare edges.

Part 3.  (Testing strategy)

My spec tests involved checking basic operations to see if they are being
represented properly. I broke down my tests into small parts: of low difficulty
to catch small bugs earlier in the process rather than losing them in more
complex tests. However, I also had to make sure that I wasn't adding redundant
tests. The lowest-level test is to test empty graphs. Then, I increased the
test complexity by adding nodes and using the "0, 1, 2" advice from the
homework page in my tests for adding nodes. I also checked for adding edges,
and finally, I recalled that nodes leading to themselves too are permissible,
so I added a reflexive edge test as well.

In my implementation tests, I wrote tests for cases that are not able
to be represented by the spec tests. My implementation tests included special
cases such as returning null, adding duplicate edges/nodes, and inspecting nodes
that do not exist in the graph. I also wrote tests for the remove edge method
because it is not part of the valid commands for .test and .expected files.


